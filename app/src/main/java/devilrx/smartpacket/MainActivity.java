package devilrx.smartpacket;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.pm.ChangedPackages;
import android.content.pm.PackageManager;
import android.content.res.AssetManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;



import io.pkts.Pcap;
import io.pkts.buffer.Buffer;
import io.pkts.packet.TCPPacket;
import io.pkts.packet.UDPPacket;
import io.pkts.protocol.Protocol;

import eu.chainfire.libsuperuser.Shell;

import static android.system.OsConstants.IPPROTO_TCP;

class CFlow {
    private int flag;
    private int num_in;
    private int num_out;
    private long byte_in;
    private long byte_out;
    private String local_ip;
    private int local_port;
    private String distant_ip;
    private int distant_port;
    private double start_time;
    private double end_time;
    private double out_in;
    private double in_out;
    private double last_out;
    private double last_in;
    private double min_IAT;

    public CFlow(double time, int dir, long num) {
        this.flag = 0;
        num_in = dir;
        num_out = 1 - dir;
        byte_in = dir * num;
        byte_out = (1 - dir) * num;
        start_time = time;
        end_time = time;
        out_in = 0.0;
        in_out = 0.0;
        min_IAT=99999;
        if (dir == 0) {
            last_in = -1;
            last_out = time;
        } else {
            last_in = time;
            last_out = -1;
        }
    }

    public void update(double time, int dir, long num) {
        if (min_IAT>time-end_time){
            min_IAT=time-end_time;
        }
        end_time = time;
        if (dir == 0) {
            if (last_in > last_out)
                in_out += time - last_in;
            last_out = time;
        } else {
            if (last_out > last_in)
                out_in += time - last_out;
            last_in = time;
        }
        this.byte_in += dir * num;
        this.byte_out += (1 - dir) * num;
        this.num_in += dir;
        this.num_out += 1 - dir;
    }

    //    public void changeTime(double time,int dir){
//        end_time=time;
//        if (dir==0){
//            if (last_in>last_out)
//                in_out += time - last_in;
//            last_out = time;
//        }
//        else{
//            if (last_out>last_in)
//                out_in += time - last_out;
//            last_in = time;
//        }
//    }
//    public void addFlag(int dir,ArrayList<String> flag){
//        flags.add(flag);
//        direction.add(dir);
//    }
//    public void addByte(int dir,long num){
//        this.byte_in+=dir*num;
//        this.byte_out+=(1-dir)*num;
//    }
//    public void addNum(int dir){
//        this.num_in+=dir;
//        this.num_out+=1-dir;
//    }
    public double getminIAT() {
        if (min_IAT==99999)return 0;
        return min_IAT;
    }

    public int getNumin() {
        return this.num_in;
    }

    public int getNumout() {
        return this.num_out;
    }

    public long getBytein() {
        return byte_in;
    }

    public long getByteout() {
        return byte_out;
    }

    public double getDuration() {
        return end_time - start_time;
    }

    //    public String getLip(){
//        return local_ip;
//    }
//    public int getLport(){
//        return local_port;
//    }
//    public String getDip(){
//        return distant_ip;
//    }
//    public int getDport(){
//        return distant_port;
//    }
//    public double getInter(){
//        return num_out/(end_time-start_time);
//    }
//    public double getASOQ(){
//        return 1.0*byte_out/num_out;
//    }
//    public double getASOA(){
//        return 1.0*byte_in/num_in;
//    }
    public double getQAIT() {
        if (end_time==start_time)return 0;
        return 1.0 * out_in / (end_time - start_time);
    }
}

class Flow{
    private ArrayList<ArrayList<String>> flags=new ArrayList<ArrayList<String>>();
    private ArrayList<Long> outlist = new ArrayList();
    private ArrayList<Double> IAToutlist = new ArrayList();
    private ArrayList<Double> IATlist = new ArrayList();
    private ArrayList<Long> bytelist = new ArrayList();
    private int flag;
    private int num_in;
    private int num_out;
    private long byte_in;
    private long byte_out;
    private String local_ip;
    private int local_port;
    private String distant_ip;
    private int distant_port;
    private double start_time;
    private double end_time;
    private double out_in;
    private double in_out;
    private double last_out;
    private double last_in;
    public Flow(double time,String lip, int lport,String dip, int dport, int dir, long num,ArrayList<String> flag){
        this.flag = 0;
        if (dir==0){
            local_ip=lip;
            local_port=lport;
            distant_ip=dip;
            distant_port=dport;
        }
        else{
            local_ip=dip;
            local_port=dport;
            distant_ip=lip;
            distant_port=lport;
        }
        num_in=dir;
        num_out=1-dir;
        byte_in=dir*num;
        byte_out=(1-dir)*num;
        start_time=time;
        end_time=time;
        out_in=0.0;
        in_out=0.0;
        bytelist.add(num);
        if (dir==0){
            last_in=-1;
            last_out=time;
            outlist.add(byte_out);
        }
        else{
            last_in=time;
            last_out=-1;
        }
        flags.add(flag);
    }

    public StringBuilder getFlag(){
        StringBuilder builder = new StringBuilder();
        // Append all Integers in StringBuilder to the StringBuilder.
        for (ArrayList<String> list : flags) {
            builder.append("[");
            for (String str : list){
                builder.append(str);
                builder.append(".");
            }
            builder.append("]");
            builder.append("-");
        }
        return builder;
    }

    public void update(double time, int dir, long num, ArrayList<String> flag){
        bytelist.add(num);
        IATlist.add(time-end_time);
        end_time=time;
        if (dir==0){
            if (last_in>last_out)
                IAToutlist.add(time-last_in);
                in_out += time - last_in;
            last_out = time;
            outlist.add(num);
        }
        else{
            if (last_out>last_in)
                out_in += time - last_out;
            last_in = time;
        }
        flags.add(flag);
        this.byte_in+=dir*num;
        this.byte_out+=(1-dir)*num;
        this.num_in+=dir;
        this.num_out+=1-dir;
    }
//    public void changeTime(double time,int dir){
//        end_time=time;
//        if (dir==0){
//            if (last_in>last_out)
//                in_out += time - last_in;
//            last_out = time;
//        }
//        else{
//            if (last_out>last_in)
//                out_in += time - last_out;
//            last_in = time;
//        }
//    }
//    public void addFlag(int dir,ArrayList<String> flag){
//        flags.add(flag);
//        direction.add(dir);
//    }
//    public void addByte(int dir,long num){
//        this.byte_in+=dir*num;
//        this.byte_out+=(1-dir)*num;
//    }
//    public void addNum(int dir){
//        this.num_in+=dir;
//        this.num_out+=1-dir;
//    }
    public double getIAT(){return in_out+out_in;}
    public int getNumin(){
        return this.num_in;
    }
    public int getNumout(){
        return this.num_out;
    }
    public long getBytein(){
        return byte_in;
    }
    public long getByteout(){
        return byte_out;
    }
    public double getDuration(){
        return end_time-start_time;
    }
    public double getBOMedian(){
        Collections.sort(outlist);
        double median;
        if (outlist.size()==0) return 0;
        if (outlist.size() % 2 == 0)
            median = ((double)outlist.get(outlist.size()/2) + (double)outlist.get(outlist.size()/2-1))/2;
        else
            median = (double)outlist.get(outlist.size()/2);
        return median;
    }
    public double getIATOutMedian(){
        Collections.sort(IAToutlist);
        double median;
        if (IAToutlist.size()==0)return 0;
        if (IAToutlist.size() % 2 == 0)
            median = (IAToutlist.get(IAToutlist.size()/2) + IAToutlist.get(IAToutlist.size()/2-1))/2;
        else
            median = IAToutlist.get(IAToutlist.size()/2);
        return median;
    }
    public int getIATWaveCount(){
        int count = 0;
        if (IATlist.size()<3)return 0;
        for (int i=0;i<IATlist.size()-2;i++){
            double first=IATlist.get(i);
            double second=IATlist.get(i+1);
            double third=IATlist.get(i+2);
            if ((second-first)*(third-second)<0)count++;
        }
        return count;
    }
    public double getByteSkew(){
        double mean=(byte_in+byte_out)/(num_in+num_out);
        double std=0;
        for (double i:bytelist){
            std+=(i-mean)*(i-mean);
        }
        std=Math.sqrt(std);
        if (std==0)return 0;
        double cu=0;
        for (double i:bytelist) {
            cu+=Math.pow((i-mean)/std, 3);
        }
        return cu/(num_out+num_in);
    }
//    public String getLip(){
//        return local_ip;
//    }
//    public int getLport(){
//        return local_port;
//    }
//    public String getDip(){
//        return distant_ip;
//    }
//    public int getDport(){
//        return distant_port;
//    }
//    public double getInter(){
//        return num_out/(end_time-start_time);
//    }
//    public double getASOQ(){
//        return 1.0*byte_out/num_out;
//    }
//    public double getASOA(){
//        return 1.0*byte_in/num_in;
//    }
    public double getQAIT() {
        if (end_time==start_time)return 0;
        return 1.0 * out_in / (end_time - start_time);
    }
//    public double getAQIT(){
//        return 1.0*in_out/(end_time-start_time);
//    }
//    public double getStart_time(){
//        return start_time;
//    }
    public int getFlagtype(){return flag;}
    public void checkFlag(){

        int num1=0;
        int num2=0;
        for (ArrayList<String> list : flags) {
            if (list.get(0).equals("1"))num1++;
            if (list.get(1).equals("RST"))num2++;
        }
        if (num1==0 && flags.get(0).size()==2 && flags.get(0).get(1).equals("SYN"))flag= 1;
        if (num2>0)flag = 0;
        if (flags.get(flags.size()-1).size()==2 && flags.get(flags.size()-1).get(1).equals("ACK"))flag = 0;
        else{
            if(flags.get(flags.size()-1).get(1).equals("FIN") && flags.get(flags.size()-1).get(2).equals("ACK")){
                if (flags.get(flags.size()-1).get(0).equals("0"))flag = 1;
                else flag = 1;
            }
            else flag = 1;
        }
    }
}

public class MainActivity extends AppCompatActivity {
    private UpdateManager mUpdateManager;
    private static final int REQUEST_EXTERNAL_STORAGE = 1;
    private static String[] PERMISSIONS_STORAGE = {
            "android.permission.READ_INTERNAL_STORAGE",
            "android.permission.READ_EXTERNAL_STORAGE",
            "android.permission.WRITE_EXTERNAL_STORAGE" };

    private ProgressDialog progressbox;
    Classifier classifier;
    Classifier flow_classifier;

    public static void verifyStoragePermissions(Activity activity) {

        try {
            //检测是否有写的权限
            int permission = ActivityCompat.checkSelfPermission(activity,
                    "android.permission.WRITE_EXTERNAL_STORAGE");
            if (permission != PackageManager.PERMISSION_GRANTED) {
                // 没有写的权限，去申请写的权限，会弹出对话框
                ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        String version="20.11.18";
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (version!="20.11.19"){
            mUpdateManager = new UpdateManager(this);
            mUpdateManager.checkUpdateInfo();
        }
//        Shell.SH.run("lsof > /mnt/sdcard/666.txt");
        Shell.SH.run("cat /proc/net/tcp | sed \"1d\" | awk '$8>10000{split($2,a,\":\");printf \"%d,%s\\n\",\"0x\"a[2],$8}' > /mnt/sdcard/666.txt");
        Shell.SH.run("cat /proc/net/tcp6 | sed \"1d\" | awk '$8>10000{split($2,a,\":\");printf \"%d,%s\\n\",\"0x\"a[2],$8}' >> /mnt/sdcard/666.txt");
        classifier = new Classifier(Utils.assetFilePath(this,"svm_model-2.pt"));
        flow_classifier = new Classifier(Utils.assetFilePath(this,"dis_real.pt"));
        verifyStoragePermissions(this);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        String fileName= "/mnt/sdcard/666.txt";
        File file= new File(fileName);

        // this gives you a 2-dimensional array of strings
        ArrayList<String[]> lines = new ArrayList<>();
        ArrayList<String> string = new ArrayList<>();
        string.add("All");
        Scanner inputStream;
        try {
            inputStream = new Scanner(file);
            while (inputStream.hasNext()) {
                String line = inputStream.next();
                string.add(line);
                String[] values = line.split(",");
                lines.add(values);
            }
        }catch (FileNotFoundException e) {
            System.out.println("break with exception");
            e.printStackTrace();
        }
        final Spinner sp2 = (Spinner)findViewById((R.id.spinner2));
        String[] choice2 = (String[])string.toArray(new String[string.size()]) ;
        ArrayAdapter bb = new ArrayAdapter(this,android.R.layout.simple_spinner_item,choice2);
        sp2.setAdapter(bb);
        final Button bt = (Button)findViewById(R.id.button_packet_capture);
        final Button bt1 = (Button)findViewById(R.id.capture_interval);
        final Spinner sp1 = (Spinner)findViewById((R.id.spinner));
        String[] choice = {"Only TCP packets","Only UDP packets"};
        ArrayAdapter aa = new ArrayAdapter(this,android.R.layout.simple_spinner_item,choice);
        sp1.setAdapter(aa);

        progressbox = new ProgressDialog(this);
        progressbox.setTitle("Initialising");
        progressbox.setMessage("Requesting root permissions..");
        progressbox.setIndeterminate(true);
        progressbox.setCancelable(false);
        progressbox.show();
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                final Boolean isRootAvailable = Shell.SU.available();
                Boolean processExists = false;
                String pid = null;
                if(isRootAvailable) {
                    List<String> out = Shell.SH.run("ps | grep packettoolstatic");
                    if(out.size() == 1) {
                        processExists = true;
                        pid = (out.get(0).split("\\s+"))[1];
                    }
                    else if(out.size() == 0) {
                        if (loadTcpdumpFromAssets() != 0)
                            throw new RuntimeException("Copying capture binary failed.");
                    }
                    else
                        throw new RuntimeException("Searching for running process returned unexpected result.");
                }

                final Boolean processExistsFinal = processExists;
                final String pidFinal = pid;
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        if (!isRootAvailable) {
                            ((TextView)findViewById(R.id.main_tv)).setText("Root permission denied or phone is not rooted!");
                            (findViewById(R.id.button_packet_capture)).setEnabled(false);
                            //(findViewById(R.id.capture_interval)).setEnabled(false);
                            //(findViewById(R.id.button_analyse)).setEnabled(false);
                        }
                        else {
                            if(processExistsFinal){
                                ((TextView)findViewById(R.id.main_tv)).setText("capture already running at pid: " + pidFinal );
                                bt.setText("Stop Capture");
                                bt.setTag(1);
                                bt1.setText("Stop Capture");
                                bt1.setTag(1);
                            }
                            else {
                                ((TextView)findViewById(R.id.main_tv)).setText("Initialization Successful.");
                                bt.setTag(0);
                                bt1.setTag(0);
                            }
                        }
                    }
                });
                progressbox.dismiss();
            }
        };
        new Thread(runnable).start();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    public void startCapture(View v) {
        Button bt = (Button)findViewById(R.id.button_packet_capture);
        bt.setEnabled(false);
        if((int)bt.getTag() == 1){
            //Using progress dialogue from main. See comment in: TcpdumpPacketCapture.stopTcpdumpCapture
            progressbox.setMessage("Killing capture process.");
            progressbox.show();
            TcpdumpPacketCapture.stopTcpdumpCapture(this);
            bt.setText("Start Capture");
            bt.setTag(0);
            ((TextView)findViewById(R.id.main_tv)).setText("Packet capture stopped. Output stored in sdcard/0001.pcap.");
            progressbox.dismiss();
        }
        else if ((int)bt.getTag() == 0){
            Spinner sp1 = (Spinner)findViewById(R.id.spinner2);
            String choice = (String) sp1.getSelectedItem();
            if (choice.equals("All")) TcpdumpPacketCapture.initialiseCapture(this, 200, 1, 0);
            else{
                String[] a = choice.split(",");
                TcpdumpPacketCapture.initialiseCapture(this, 200, 1, Integer.parseInt(a[0]));
            }
            bt.setText("Stop Capture");
            bt.setTag(1);
        }
        bt.setEnabled(true);
    }

    public void stopAndExitActivity(View v) {
        TcpdumpPacketCapture.stopTcpdumpCapture(this);
        finish();
    }

    public void StartAnalysing(View v) throws IOException {
        ArrayList<String> string = new ArrayList<>();
        string.add("All");
        final Pcap pcap = Pcap.openStream("/mnt/sdcard/repeat_1_times.pcap");
        File file = new File("/mnt/sdcard/repeat_1_times.pcap");
        FileWriter writer_f = new FileWriter("/mnt/sdcard/0001_flow.csv");
//        final StringBuilder sb = new StringBuilder("ArrivalTime,Name,TotalLength,CapturedLength,SrcIP,SrcPort,DescIP,DescPort,Identification,IpChecksum,IpVersion,TcpFlag\n");
        final StringBuilder sf1 = new StringBuilder("Duration,Packet_out,Byte_out,Byte_out_median,Byte_sum,Byte_mean,Byte_out_mean,Byte_skew,IAT_out_median,IAT_Wavecount,QAIT,Flag_type,magnitude,c_packet_out,c_byte_out,c_pout_pin,c_byte_out_mean,c_byte_sum,c_byte_mean,c_min_IAT\n");
        writer_f.write(sf1.toString());
        final StringBuilder sf = new StringBuilder();
        final StringBuilder st = new StringBuilder();
        Map<String,Flow> map = new LinkedHashMap<String,Flow>();
        Map<String,CFlow> cmap = new LinkedHashMap<String,CFlow>();
        int[] num = {0};
        try {
            pcap.loop(packet -> {
                num[0] += 1;
                System.out.println(num[0]);
                if (num[0] % 1000 == 0) {
                    int count = 0;
                    for( String key : map.keySet() ) {
                        Flow temp=map.get(key);
                        CFlow ctemp=cmap.get(key);
                        try {
                            int ni = temp.getNumin();
                            int no = temp.getNumout();
                            long bo = temp.getByteout();
                            long bi = temp.getBytein();
                            long bom,bim;
                            if (no==0)bom=0;
                            else bom = bo / no;
                            if (ni==0)bim = 0;
                            else bim=bi / ni;
                            int cni = ctemp.getNumin();
                            int cno = ctemp.getNumout();
                            long cbo = ctemp.getByteout();
                            long cbi = ctemp.getBytein();
                            long cbom,cpp;
                            if (cno==0){
                                cbom=0;
                            }
                            else {
                                cbom = cbo / cno;
                            }
                            if (cni==0){
                                cpp=0;
                            }
                            else {
                                cpp=cno/cni;
                            }
                            sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

                        }
                        catch (NullPointerException e) {
                            continue;
                        }

                    }
                    System.out.println(sf.toString());
                    writer_f.write(sf.toString());
                    map.clear();
                }
                if (num[0] % 20000 == 0) {
                    cmap.clear();
                }
                int dir = 0;
                System.out.println(num[0]);
                if (packet.hasProtocol(Protocol.TCP)) {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    TCPPacket tcpPacket = (TCPPacket) packet.getPacket(Protocol.TCP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(tcpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort() + "-" + tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort());
                    else
                        key.append(tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort() + "-" + tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("" + dir);
                    if (tcpPacket.isFIN()) array1.add("FIN");
                    if (tcpPacket.isSYN()) array1.add("SYN");
                    if (tcpPacket.isRST()) array1.add("RST");
                    if (tcpPacket.isPSH()) array1.add("PSH");
                    if (tcpPacket.isACK()) array1.add("ACK");
                    if (tcpPacket.isURG()) array1.add("URG");
                    if (tcpPacket.isECE()) array1.add("ECE");
                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(tcpPacket.getArrivalTime() / 1000000.0, tcpPacket.getSourceIP(), tcpPacket.getSourcePort(), tcpPacket.getDestinationIP(), tcpPacket.getDestinationPort(), dir, tcpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(tcpPacket.getSourcePort());
                    } else port = String.valueOf(tcpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + tcpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
//                else if (packet.hasProtocol(Protocol.UDP)) {
//
//                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
//                    Buffer buffer = udpPacket.getPayload();
//                    if (buffer != null) {
//                        System.out.println("UDP: " + udpPacket.getDestinationIP());
//                    }
//                }
                else if (packet.hasProtocol(Protocol.UDP)) {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(udpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort() + "-" + udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort());
                    else
                        key.append(udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort() + "-" + udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("SYN");
//                    array1.add("" + dir);
//                    if (tcpPacket.isFIN()) array1.add("FIN");
//                    if (tcpPacket.isSYN()) array1.add("SYN");
//                    if (tcpPacket.isRST()) array1.add("RST");
//                    if (tcpPacket.isPSH()) array1.add("PSH");
//                    if (tcpPacket.isACK()) array1.add("ACK");
//                    if (tcpPacket.isURG()) array1.add("URG");
//                    if (tcpPacket.isECE()) array1.add("ECE");
//                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(udpPacket.getArrivalTime() / 1000000.0, udpPacket.getSourceIP(), udpPacket.getSourcePort(), udpPacket.getDestinationIP(), udpPacket.getDestinationPort(), dir, udpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(udpPacket.getSourcePort());
                    } else port = String.valueOf(udpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + udpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
                return true;
            });
        }catch (Exception e){
            System.out.println("Go ahead");
        }

//        FileWriter writer_p = new FileWriter("/mnt/sdcard/0001_packet.csv");
//        writer_p.write(sb.toString());
//        writer_p.close();

        int count = 0;
        for( String key : map.keySet() ) {
            Flow temp=map.get(key);
            CFlow ctemp=cmap.get(key);
            try {
                int ni = temp.getNumin();
                int no = temp.getNumout();
                long bo = temp.getByteout();
                long bi = temp.getBytein();
                long bom,bim;
                if (no==0)bom=0;
                else bom = bo / no;
                if (ni==0)bim = 0;
                else bim=bi / ni;
                int cni = ctemp.getNumin();
                int cno = ctemp.getNumout();
                long cbo = ctemp.getByteout();
                long cbi = ctemp.getBytein();
                long cbom,cpp;
                if (cno==0){
                    cbom=0;
                }
                else {
                    cbom = cbo / cno;
                }
                if (cni==0){
                    cpp=0;
                }
                else {
                    cpp=cno/cni;
                }
                sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

            }
            catch (NullPointerException e) {
                continue;
            }

        }
        System.out.println(sf.toString());
        writer_f.write(sf.toString());
        writer_f.close();


        final Spinner sp2 = (Spinner)findViewById((R.id.spinner2));
        String[] choice2 = (String[])string.toArray(new String[string.size()]) ;
        ArrayAdapter bb = new ArrayAdapter(this,android.R.layout.simple_spinner_item,choice2);
        sp2.setAdapter(bb);

        //System.out.println(sb);
    }

    public void AnalysingAndDelete(String filename) throws IOException {
        ArrayList<String> string = new ArrayList<>();
        string.add("All");
        final Pcap pcap = Pcap.openStream("/mnt/sdcard/"+filename+".pcap");
        File file = new File("/mnt/sdcard/"+filename+".pcap");

//上面是在模拟器端端路径，在安卓端要改成如下路径：
//        final Pcap pcap = Pcap.openStream("/mnt/sdcard/"+filename+".pcap");
//        File file = new File("/mnt/sdcard/"+filename+".pcap");

//        if(file.length() == 0){
//            file.delete();
//            return;
//        }
//        final StringBuilder sb = new StringBuilder("ArrivalTime,Name,TotalLength,CapturedLength,SrcIP,SrcPort,DescIP,DescPort,Identification,IpChecksum,IpVersion,TcpFlag\n");

        FileWriter writer_f = new FileWriter("/mnt/sdcard/"+filename+".csv");
//        final StringBuilder sb = new StringBuilder("ArrivalTime,Name,TotalLength,CapturedLength,SrcIP,SrcPort,DescIP,DescPort,Identification,IpChecksum,IpVersion,TcpFlag\n");
        final StringBuilder sf1 = new StringBuilder("Duration,Packet_out,Byte_out,Byte_out_median,Byte_sum,Byte_mean,Byte_out_mean,Byte_skew,IAT_out_median,IAT_Wavecount,QAIT,Flag_type,magnitude,c_packet_out,c_byte_out,c_pout_pin,c_byte_out_mean,c_byte_sum,c_byte_mean,c_min_IAT\n");
        writer_f.write(sf1.toString());
        final StringBuilder sf = new StringBuilder();
        final StringBuilder st = new StringBuilder();
        Map<String,Flow> map = new LinkedHashMap<String,Flow>();
        Map<String,CFlow> cmap = new LinkedHashMap<String,CFlow>();
        int[] num = {0};
        try {
            pcap.loop(packet -> {
                num[0] += 1;
                System.out.println(num[0]);
                if (num[0] % 1000 == 0) {
                    int count = 0;
                    for( String key : map.keySet() ) {
                        Flow temp=map.get(key);
                        CFlow ctemp=cmap.get(key);
                        try {
                            int ni = temp.getNumin();
                            int no = temp.getNumout();
                            long bo = temp.getByteout();
                            long bi = temp.getBytein();
                            long bom,bim;
                            if (no==0)bom=0;
                            else bom = bo / no;
                            if (ni==0)bim = 0;
                            else bim=bi / ni;
                            int cni = ctemp.getNumin();
                            int cno = ctemp.getNumout();
                            long cbo = ctemp.getByteout();
                            long cbi = ctemp.getBytein();
                            long cbom,cpp;
                            if (cno==0){
                                cbom=0;
                            }
                            else {
                                cbom = cbo / cno;
                            }
                            if (cni==0){
                                cpp=0;
                            }
                            else {
                                cpp=cno/cni;
                            }
                            sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

                        }
                        catch (NullPointerException e) {
                            continue;
                        }

                    }
                    System.out.println(sf.toString());
                    writer_f.write(sf.toString());
                    map.clear();
                }
                if (num[0] % 20000 == 0) {
                    cmap.clear();
                }
                int dir = 0;
                System.out.println(num[0]);
                if (packet.hasProtocol(Protocol.TCP)) {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    TCPPacket tcpPacket = (TCPPacket) packet.getPacket(Protocol.TCP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(tcpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort() + "-" + tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort());
                    else
                        key.append(tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort() + "-" + tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("" + dir);
                    if (tcpPacket.isFIN()) array1.add("FIN");
                    if (tcpPacket.isSYN()) array1.add("SYN");
                    if (tcpPacket.isRST()) array1.add("RST");
                    if (tcpPacket.isPSH()) array1.add("PSH");
                    if (tcpPacket.isACK()) array1.add("ACK");
                    if (tcpPacket.isURG()) array1.add("URG");
                    if (tcpPacket.isECE()) array1.add("ECE");
                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(tcpPacket.getArrivalTime() / 1000000.0, tcpPacket.getSourceIP(), tcpPacket.getSourcePort(), tcpPacket.getDestinationIP(), tcpPacket.getDestinationPort(), dir, tcpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(tcpPacket.getSourcePort());
                    } else port = String.valueOf(tcpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + tcpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
//                else if (packet.hasProtocol(Protocol.UDP)) {
//
//                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
//                    Buffer buffer = udpPacket.getPayload();
//                    if (buffer != null) {
//                        System.out.println("UDP: " + udpPacket.getDestinationIP());
//                    }
//                }
                else if (packet.hasProtocol(Protocol.UDP)) {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(udpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort() + "-" + udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort());
                    else
                        key.append(udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort() + "-" + udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("SYN");
//                    array1.add("" + dir);
//                    if (tcpPacket.isFIN()) array1.add("FIN");
//                    if (tcpPacket.isSYN()) array1.add("SYN");
//                    if (tcpPacket.isRST()) array1.add("RST");
//                    if (tcpPacket.isPSH()) array1.add("PSH");
//                    if (tcpPacket.isACK()) array1.add("ACK");
//                    if (tcpPacket.isURG()) array1.add("URG");
//                    if (tcpPacket.isECE()) array1.add("ECE");
//                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(udpPacket.getArrivalTime() / 1000000.0, udpPacket.getSourceIP(), udpPacket.getSourcePort(), udpPacket.getDestinationIP(), udpPacket.getDestinationPort(), dir, udpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(udpPacket.getSourcePort());
                    } else port = String.valueOf(udpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + udpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
                return true;
            });
        }catch (Exception e){
            System.out.println("Go ahead");
        }

//        FileWriter writer_p = new FileWriter("/mnt/sdcard/0001_packet.csv");
//        writer_p.write(sb.toString());
//        writer_p.close();

        int count = 0;
        for( String key : map.keySet() ) {
            Flow temp=map.get(key);
            CFlow ctemp=cmap.get(key);
            try {
                int ni = temp.getNumin();
                int no = temp.getNumout();
                long bo = temp.getByteout();
                long bi = temp.getBytein();
                long bom,bim;
                if (no==0)bom=0;
                else bom = bo / no;
                if (ni==0)bim = 0;
                else bim=bi / ni;
                int cni = ctemp.getNumin();
                int cno = ctemp.getNumout();
                long cbo = ctemp.getByteout();
                long cbi = ctemp.getBytein();
                long cbom,cpp;
                if (cno==0){
                    cbom=0;
                }
                else {
                    cbom = cbo / cno;
                }
                if (cni==0){
                    cpp=0;
                }
                else {
                    cpp=cno/cni;
                }
                sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

            }
            catch (NullPointerException e) {
                continue;
            }

        }
        System.out.println(sf.toString());
        writer_f.write(sf.toString());
        writer_f.close();


//        file.delete();
        //System.out.println(sb);

        final Spinner sp2 = (Spinner)findViewById((R.id.spinner2));
        String[] choice2 = (String[])string.toArray(new String[string.size()]) ;
        ArrayAdapter bb = new ArrayAdapter(this,android.R.layout.simple_spinner_item,choice2);
        sp2.setAdapter(bb);
    }

    public void CaptureWithInterval(View v) throws IOException {
        ((TextView) findViewById(R.id.Interval)).setText("");
        EditText input1 = findViewById(R.id.input1);
        EditText input2 = findViewById(R.id.input2);
        //这边之后要改，要判定用户的输入是不是合法，是否是空值
        int packets = Integer.parseInt(input1.getText().toString());//interval是每分钟抓的包的数量
        int times = Integer.parseInt(input2.getText().toString());//times是这个程序执行次数
        long time = 200/packets * 1000; // 因为可执行文件是一次性抓200个包，所以time是执行一次的间隔时间（ms）

        System.out.println(times);
        System.out.println(time);


        for(int i = 0; i < times; i ++) {
            try{
                long start=System.currentTimeMillis();   //获取开始时间
//                TcpdumpPacketCapture.stopTcpdumpCapture(this);
                TcpdumpPacketCapture.initialiseCapture(this, packets, i,0);



                long end=System.currentTimeMillis(); //获取结束时间
                if (1000 > (end - start)){
                    try {
                        Thread.sleep(1000-(end-start)); //暂停，每一秒输出一次

                    }
                    catch (InterruptedException e) {
                        System.out.println("wrong");
                        return;
                    }
                }
                else {
                    ((TextView) findViewById(R.id.Interval)).setText("you'd better choose less packets");
                }

                //AnalysingAndDelete( filename);
            }
            catch (Exception e) {
                ((TextView) findViewById(R.id.Interval)).setText(e.toString());
                System.out.println("wrongwrong");
                return;
            }
        }
    }

    public void AnalysingALL(View v) throws IOException {
        EditText input2 = findViewById(R.id.input2);
        int times = Integer.parseInt(input2.getText().toString());//times是这个程序执行次数
        System.out.println(times);
        for(int i = 0; i < times; i ++) {
            try {
                String filename = "repeat_" + i +"_times";
                AnalysingAndDelete( filename);
            }
            catch (Exception e) {
                ((TextView) findViewById(R.id.Interval)).setText(e.toString());
                return;
            }
        }

    }

    public void AnalysingChoosen(View v) throws IOException {
        Spinner sp1 = (Spinner)findViewById(R.id.spinner);
        String choice = (String) sp1.getSelectedItem();
        EditText input2 = findViewById(R.id.input2);
        int times = Integer.parseInt(input2.getText().toString());//times是这个程序执行次数
        for(int i = 0; i < times; i ++) {
            try {
                String filename = "repeat_" + i +"_times";
                AnalysingWithChoice(filename, choice);
            }
            catch (Exception e) {
                ((TextView) findViewById(R.id.Interval)).setText(e.toString());
                return;
            }
        }
    }

    public void AnalysingWithChoice(String filename, String Choice) throws IOException {
//        final Pcap pcap = Pcap.openStream("/mnt/sdcard/"+filename+".pcap");
//        File file = new File("/mnt/sdcard/"+filename+".pcap");
//        System.out.println(Choice);

//上面是在模拟器端端路径，在安卓端要改成如下路径：
        final Pcap pcap = Pcap.openStream("/mnt/sdcard/"+filename+".pcap");
        File file = new File("/mnt/sdcard/"+filename+".pcap");

        if(file.length() == 0){
            file.delete();
            return;
        }

//        final StringBuilder sb = new StringBuilder(Choice+"DestPort\n");

        FileWriter writer_f = new FileWriter("/mnt/sdcard/"+filename+".csv");
//        final StringBuilder sb = new StringBuilder("ArrivalTime,Name,TotalLength,CapturedLength,SrcIP,SrcPort,DescIP,DescPort,Identification,IpChecksum,IpVersion,TcpFlag\n");
        final StringBuilder sf1 = new StringBuilder("Duration,Packet_out,Byte_out,Byte_out_median,Byte_sum,Byte_mean,Byte_out_mean,Byte_skew,IAT_out_median,IAT_Wavecount,QAIT,Flag_type,magnitude,c_packet_out,c_byte_out,c_pout_pin,c_byte_out_mean,c_byte_sum,c_byte_mean,c_min_IAT\n");
        writer_f.write(sf1.toString());
        final StringBuilder sf = new StringBuilder();
        final StringBuilder st = new StringBuilder();
        Map<String,Flow> map = new LinkedHashMap<String,Flow>();
        Map<String,CFlow> cmap = new LinkedHashMap<String,CFlow>();
        int[] num = {0};
        try {
            pcap.loop(packet -> {
                num[0] += 1;
                System.out.println(num[0]);
                if (num[0] % 1000 == 0) {
                    int count = 0;
                    for( String key : map.keySet() ) {
                        Flow temp=map.get(key);
                        CFlow ctemp=cmap.get(key);
                        try {
                            int ni = temp.getNumin();
                            int no = temp.getNumout();
                            long bo = temp.getByteout();
                            long bi = temp.getBytein();
                            long bom,bim;
                            if (no==0)bom=0;
                            else bom = bo / no;
                            if (ni==0)bim = 0;
                            else bim=bi / ni;
                            int cni = ctemp.getNumin();
                            int cno = ctemp.getNumout();
                            long cbo = ctemp.getByteout();
                            long cbi = ctemp.getBytein();
                            long cbom,cpp;
                            if (cno==0){
                                cbom=0;
                            }
                            else {
                                cbom = cbo / cno;
                            }
                            if (cni==0){
                                cpp=0;
                            }
                            else {
                                cpp=cno/cni;
                            }
                            sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

                        }
                        catch (NullPointerException e) {
                            continue;
                        }

                    }
                    System.out.println(sf.toString());
                    writer_f.write(sf.toString());
                    map.clear();
                }
                if (num[0] % 20000 == 0) {
                    cmap.clear();
                }
                int dir = 0;
                System.out.println(num[0]);
                if (packet.hasProtocol(Protocol.TCP)&&Choice=="Only TCP packets") {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    TCPPacket tcpPacket = (TCPPacket) packet.getPacket(Protocol.TCP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(tcpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort() + "-" + tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort());
                    else
                        key.append(tcpPacket.getDestinationIP() + ":" + tcpPacket.getDestinationPort() + "-" + tcpPacket.getSourceIP() + ":" + tcpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("" + dir);
                    if (tcpPacket.isFIN()) array1.add("FIN");
                    if (tcpPacket.isSYN()) array1.add("SYN");
                    if (tcpPacket.isRST()) array1.add("RST");
                    if (tcpPacket.isPSH()) array1.add("PSH");
                    if (tcpPacket.isACK()) array1.add("ACK");
                    if (tcpPacket.isURG()) array1.add("URG");
                    if (tcpPacket.isECE()) array1.add("ECE");
                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(tcpPacket.getArrivalTime() / 1000000.0, tcpPacket.getSourceIP(), tcpPacket.getSourcePort(), tcpPacket.getDestinationIP(), tcpPacket.getDestinationPort(), dir, tcpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(tcpPacket.getArrivalTime() / 1000000.0, dir, tcpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(tcpPacket.getSourcePort());
                    } else port = String.valueOf(tcpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + tcpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
//                else if (packet.hasProtocol(Protocol.UDP)) {
//
//                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
//                    Buffer buffer = udpPacket.getPayload();
//                    if (buffer != null) {
//                        System.out.println("UDP: " + udpPacket.getDestinationIP());
//                    }
//                }
                else if (packet.hasProtocol(Protocol.UDP)&&Choice=="Only UDP packets") {
                    //                MACPacket macPacket = (MACPacket) packet.getPacket(Protocol.TCP);
                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
                    if (Utils.getIPAddress(true).getHostAddress().equals(udpPacket.getDestinationIP())) {
                        dir = 1;
                    }
                    StringBuilder key = new StringBuilder();
                    if (dir == 0)
                        key.append(udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort() + "-" + udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort());
                    else
                        key.append(udpPacket.getDestinationIP() + ":" + udpPacket.getDestinationPort() + "-" + udpPacket.getSourceIP() + ":" + udpPacket.getSourcePort());
                    ArrayList<String> array1 = new ArrayList();
                    array1.add("SYN");
//                    array1.add("" + dir);
//                    if (tcpPacket.isFIN()) array1.add("FIN");
//                    if (tcpPacket.isSYN()) array1.add("SYN");
//                    if (tcpPacket.isRST()) array1.add("RST");
//                    if (tcpPacket.isPSH()) array1.add("PSH");
//                    if (tcpPacket.isACK()) array1.add("ACK");
//                    if (tcpPacket.isURG()) array1.add("URG");
//                    if (tcpPacket.isECE()) array1.add("ECE");
//                    if (tcpPacket.isCWR()) array1.add("CWR");
                    if (map.containsKey(key.toString())) {
                        map.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength(), array1);
                    } else {
                        map.put(key.toString(), new Flow(udpPacket.getArrivalTime() / 1000000.0, udpPacket.getSourceIP(), udpPacket.getSourcePort(), udpPacket.getDestinationIP(), udpPacket.getDestinationPort(), dir, udpPacket.getTotalLength(), array1));
                    }
                    if (cmap.containsKey(key.toString())) {
                        cmap.get(key.toString()).update(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength());
                    } else {
                        cmap.put(key.toString(), new CFlow(udpPacket.getArrivalTime() / 1000000.0, dir, udpPacket.getTotalLength()));
                    }
                    String port = new String();
                    if (dir == 0) {
                        port = String.valueOf(udpPacket.getSourcePort());
                    } else port = String.valueOf(udpPacket.getDestinationPort());
                    //                if (string.contains(port)==false){
                    //                    InetAddress src= new InetAddress.;
                    //                    int uid=ConnectivityManager.getConnectionOwnerUid(IPPROTO_TCP,tcpPacket.getSourceIP());
                    //                    string.add(port);
                    //                }

                    StringBuilder builder = new StringBuilder();
                    // Append all Integers in StringBuilder to the StringBuilder.
                    for (String number : array1) {
                        builder.append(number);
                        builder.append(":");
                    }
                    String a = ((TextView) findViewById(R.id.main_tv)).getText().toString();
                    String b = a + udpPacket.getDestinationIP();
//                    ((TextView) findViewById(R.id.main_tv)).setText(b);
                    //                sb.append(tcpPacket.getArrivalTime()/1000000.0 + "," + tcpPacket.getName() + "," + tcpPacket.getTotalLength() + "," + tcpPacket.getCapturedLength() + "," + tcpPacket.getSourceIP() + "," + tcpPacket.getSourcePort() + "," + tcpPacket.getDestinationIP() + "," + tcpPacket.getDestinationPort() + "," + tcpPacket.getIdentification() + "," + tcpPacket.getIpChecksum() + "," + tcpPacket.getVersion() + "," + builder + "\n");
                    //System.out.println(sb);
                }
//                else if (packet.hasProtocol(Protocol.UDP)) {
//
//                    UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
//                    Buffer buffer = udpPacket.getPayload();
//                    if (buffer != null) {
//                        System.out.println("UDP: " + udpPacket.getDestinationIP());
//                    }
//                }
                return true;
            });
        }catch (Exception e){
            System.out.println("Go ahead");
        }

//        FileWriter writer_p = new FileWriter("/mnt/sdcard/0001_packet.csv");
//        writer_p.write(sb.toString());
//        writer_p.close();

        int count = 0;
        for( String key : map.keySet() ) {
            Flow temp=map.get(key);
            CFlow ctemp=cmap.get(key);
            try {
                int ni = temp.getNumin();
                int no = temp.getNumout();
                long bo = temp.getByteout();
                long bi = temp.getBytein();
                long bom,bim;
                if (no==0)bom=0;
                else bom = bo / no;
                if (ni==0)bim = 0;
                else bim=bi / ni;
                int cni = ctemp.getNumin();
                int cno = ctemp.getNumout();
                long cbo = ctemp.getByteout();
                long cbi = ctemp.getBytein();
                long cbom,cpp;
                if (cno==0){
                    cbom=0;
                }
                else {
                    cbom = cbo / cno;
                }
                if (cni==0){
                    cpp=0;
                }
                else {
                    cpp=cno/cni;
                }
                sf.append(temp.getDuration() + "," + String.valueOf(no) + "," + String.valueOf(bo) + "," + String.valueOf(temp.getBOMedian())+ "," + String.valueOf(bi + bo) + "," + String.valueOf((bi + bo) / (ni + no)) + "," + String.valueOf(bom)+ "," + String.valueOf(temp.getByteSkew())+ "," + String.valueOf(temp.getIATOutMedian())+ "," + String.valueOf(temp.getIATWaveCount()) + "," + String.valueOf(temp.getQAIT()) + "," + String.valueOf(temp.getFlagtype())+ "," + String.valueOf(Math.sqrt(bom * bom + bim * bim))+ ","+ String.valueOf(cno)+ ","+ String.valueOf(cbo)+ ","+ String.valueOf(cpp)+ ","+ String.valueOf(cbom)+ ","+ String.valueOf(cbi+cbo)+ ","+ String.valueOf((cbi+cbo)/(cni+cno))+ ","+ String.valueOf(ctemp.getminIAT())+"\n");

            }
            catch (NullPointerException e) {
                continue;
            }

        }
        System.out.println(sf.toString());
        writer_f.write(sf.toString());
        writer_f.close();

//        pcap.loop(packet -> {
//            if (packet.hasProtocol(Protocol.TCP) && Choice == "Only TCP packets") {
//                TCPPacket tcpPacket = (TCPPacket) packet.getPacket(Protocol.TCP);
//                ArrayList<String> array1 = new ArrayList();
//                if (tcpPacket.isFIN())array1.add("FIN");
//                if (tcpPacket.isSYN())array1.add("SYN");
//                if (tcpPacket.isRST())array1.add("RST");
//                if (tcpPacket.isPSH())array1.add("PSH");
//                if (tcpPacket.isACK())array1.add("ACK");
//                if (tcpPacket.isURG())array1.add("URG");
//                if (tcpPacket.isECE())array1.add("ECE");
//                if (tcpPacket.isCWR())array1.add("CWR");
//                StringBuilder builder = new StringBuilder();
//                // Append all Integers in StringBuilder to the StringBuilder.
//                for (String number : array1) {
//                    builder.append(number);
//                    builder.append(":");
//                }
//                String a = ((TextView)findViewById(R.id.main_tv)).getText().toString();
//                String b = a+tcpPacket.getDestinationIP();
//                ((TextView)findViewById(R.id.main_tv)).setText(b);
//                sb.append(tcpPacket.getArrivalTime()+","+tcpPacket.getName()+","+tcpPacket.getTotalLength()+","+tcpPacket.getCapturedLength()+","+tcpPacket.getSourceIP()+","+tcpPacket.getSourcePort()+","+tcpPacket.getDestinationIP()+","+tcpPacket.getDestinationPort()+","+tcpPacket.getIdentification()+","+tcpPacket.getIpChecksum()+","+tcpPacket.getVersion()+","+builder+"\n");
//                //System.out.println(sb);
//            }
//            else if (packet.hasProtocol(Protocol.UDP) && Choice == "Only UDP packets") {
//
//                UDPPacket udpPacket = (UDPPacket) packet.getPacket(Protocol.UDP);
//                Buffer buffer = udpPacket.getPayload();
//                if (buffer != null) {
//                    System.out.println("UDP: " + udpPacket.getDestinationIP());
//                }
//                String a = ((TextView)findViewById(R.id.main_tv)).getText().toString();
//                String b = a+udpPacket.getDestinationIP();
//                ((TextView)findViewById(R.id.main_tv)).setText(b);
//                sb.append(udpPacket.getDestinationPort()+"\n");
//            }
//            return true;
//        });
//        FileWriter writer = new FileWriter("/mnt/sdcard/"+filename+".csv");
//        writer.write(sb.toString());
//        writer.close();

//        file.delete();
        //System.out.println(sb);
    }

    private int loadTcpdumpFromAssets(){
        int retval = 0;
        // updating progress message from other thread causes exception.
        // progressbox.setMessage("Setting up data..");
        String rootDataPath = getApplicationInfo().dataDir + "/files";
        String filePath = rootDataPath + "/packettoolstatic";
        File file = new File(filePath);
        AssetManager assetManager = getAssets();

        try{
            if (file.exists()) {
                Shell.SH.run("chmod 755 " + filePath);
                return retval;
            }
            new File(rootDataPath).mkdirs();
            retval = copyFileFromAsset(assetManager, "packettoolstatic", filePath);
            // Mark the binary executable
            Shell.SH.run("chmod 755 " + filePath);
        }
        catch(Exception ex)
        {
            ex.printStackTrace();
            retval = -1;
        }
        return retval;
    }

    private int copyFileFromAsset(AssetManager assetManager, String sourcePath, String destPath) {
        byte[] buff = new byte[1024];
        int len;
        InputStream in;
        OutputStream out;
        try {
            in = assetManager.open(sourcePath);
            new File(destPath).createNewFile();
            out = new FileOutputStream(destPath);
            // write file
            while((len = in.read(buff)) != -1){
                out.write(buff, 0, len);
            }
            in.close();
            out.flush();
            out.close();
        }
        catch(Exception ex) {
            ex.printStackTrace();
            return -1;
        }
        return 0;
    }

    public void PacketDataToModel(View view) throws IOException {
        String fileName= "/mnt/sdcard/0001_flow.csv";
        File file= new File(fileName);
        final StringBuilder sb = new StringBuilder("prediction\n");

        // this gives you a 2-dimensional array of strings
        List<List<String>> lines = new ArrayList<>();
        Scanner inputStream;

        try{
            inputStream = new Scanner(file);
            while(inputStream.hasNext()){
                String line= inputStream.next();
                String[] values = line.split(",");
                // this adds the currently parsed line to the 2-dimensional string array
                lines.add(Arrays.asList(values));
            }
            inputStream.close();
            System.out.println("read file success");
        }catch (FileNotFoundException e) {
            System.out.println("break with exception");
            e.printStackTrace();
        }

        //这flow的数据是25个feature
        float[][] data = new float[lines.size()][20];

        System.out.println(lines.get(1));
        for(int i = 1; i < lines.size(); i ++){
            float[] nowLine = new float[20];
            nowLine[0] = Float.parseFloat(lines.get(i).get(0));
            nowLine[1] = Float.parseFloat(lines.get(i).get(1));
            nowLine[2] = Float.parseFloat(lines.get(i).get(2));
            nowLine[3] = Float.parseFloat(lines.get(i).get(3));
            nowLine[4] = Float.parseFloat(lines.get(i).get(4));
            nowLine[5] = Float.parseFloat(lines.get(i).get(5));
            nowLine[6] = Float.parseFloat(lines.get(i).get(6));
            nowLine[7] = Float.parseFloat(lines.get(i).get(7));
            nowLine[8] = Float.parseFloat(lines.get(i).get(8));
            nowLine[9] = Float.parseFloat(lines.get(i).get(9));
            nowLine[10] = Float.parseFloat(lines.get(i).get(10));
            nowLine[11] = Float.parseFloat(lines.get(i).get(11));
            nowLine[12] = Float.parseFloat(lines.get(i).get(12));
            nowLine[13] = Float.parseFloat(lines.get(i).get(13));
            nowLine[14] = Float.parseFloat(lines.get(i).get(14));
            nowLine[15] = Float.parseFloat(lines.get(i).get(15));
            nowLine[16] = Float.parseFloat(lines.get(i).get(16));
            nowLine[17] = Float.parseFloat(lines.get(i).get(17));
            nowLine[18] = Float.parseFloat(lines.get(i).get(18));
            nowLine[19] = Float.parseFloat(lines.get(i).get(19));
            data[i-1] = nowLine;
        }

        System.out.println("total number : "+lines.size());
        int total_benign = 0;
        int total_malicious = 0;
        for(int i = 1; i < lines.size(); i ++){
            float[] pred = classifier.predict(data[i]);
            //System.out.println(pred[0]);
            if (pred[0] <= 0.0){
                sb.append("malicious\n");
                total_malicious+=1;
            }
            else{
                sb.append("benign\n");
                total_benign+=1;
            }
        }

        sb.insert(0, "total malicious: " + total_malicious + "\n");
        sb.insert(0, "total benign: " + total_benign + "\n");
        sb.insert(0, "total number : "+lines.size() + "\n");


        System.out.println("total benign: " + total_benign);
        System.out.println("total malicious: " + total_malicious);

        FileWriter writer = new FileWriter("/mnt/sdcard/svm_labels.csv");
        writer.write(sb.toString());
        writer.close();

        System.out.println("flow label file construct successfully");
    }


        // the following code lets you iterate through the 2-dimensional array
//        int lineNo = 1;
//        for(List<String> line: lines) {
//            int columnNo = 1;
//            for (String value: line) {
//                System.out.println("Line " + lineNo + " Column " + columnNo + ": " + value);
//                columnNo++;
//            }
//            lineNo++;
//        }


    public void FlowDataToModel(View view) throws IOException {
        String fileName= "/mnt/sdcard/0001_flow.csv";
        File file= new File(fileName);
        final StringBuilder sb = new StringBuilder("prediction\n");

        // this gives you a 2-dimensional array of strings
        List<List<String>> lines = new ArrayList<>();
        Scanner inputStream;

        try{
            inputStream = new Scanner(file);
            while(inputStream.hasNext()){
                String line= inputStream.next();
                String[] values = line.split(",");
                // this adds the currently parsed line to the 2-dimensional string array
                lines.add(Arrays.asList(values));
            }
            inputStream.close();
            System.out.println("read file success");
        }catch (FileNotFoundException e) {
            System.out.println("break with exception");
            e.printStackTrace();
        }

        //这flow的数据是25个feature
        float[][] data = new float[lines.size()][20];

        System.out.println(lines.get(1));
        for(int i = 1; i < lines.size(); i ++){
            float[] nowLine = new float[20];
            nowLine[0] = Float.parseFloat(lines.get(i).get(0));
            nowLine[1] = Float.parseFloat(lines.get(i).get(1));
            nowLine[2] = Float.parseFloat(lines.get(i).get(2));
            nowLine[3] = Float.parseFloat(lines.get(i).get(3));
            nowLine[4] = Float.parseFloat(lines.get(i).get(4));
            nowLine[5] = Float.parseFloat(lines.get(i).get(5));
            nowLine[6] = Float.parseFloat(lines.get(i).get(6));
            nowLine[7] = Float.parseFloat(lines.get(i).get(7));
            nowLine[8] = Float.parseFloat(lines.get(i).get(8));
            nowLine[9] = Float.parseFloat(lines.get(i).get(9));
            nowLine[10] = Float.parseFloat(lines.get(i).get(10));
            nowLine[11] = Float.parseFloat(lines.get(i).get(11));
            nowLine[12] = Float.parseFloat(lines.get(i).get(12));
            nowLine[13] = Float.parseFloat(lines.get(i).get(13));
            nowLine[14] = Float.parseFloat(lines.get(i).get(14));
            nowLine[15] = Float.parseFloat(lines.get(i).get(15));
            nowLine[16] = Float.parseFloat(lines.get(i).get(16));
            nowLine[17] = Float.parseFloat(lines.get(i).get(17));
            nowLine[18] = Float.parseFloat(lines.get(i).get(18));
            nowLine[19] = Float.parseFloat(lines.get(i).get(19));
            data[i-1] = nowLine;
        }

        System.out.println("total number : "+lines.size());
        int total_benign = 0;
        int total_malicious = 0;
        for(int i = 1; i < lines.size(); i ++){
            float[] pred = flow_classifier.predict(data[i]);
            if (pred[0] == 1.0){
                sb.append("malicious\n");
                total_malicious+=1;
            }
            else{
                sb.append("benign\n");
                total_benign+=1;
            }
        }

        sb.insert(0, "total malicious: " + total_malicious + "\n");
        sb.insert(0, "total benign: " + total_benign + "\n");
        sb.insert(0, "total number : "+lines.size() + "\n");


        System.out.println("total benign: " + total_benign);
        System.out.println("total malicious: " + total_malicious);

        FileWriter writer = new FileWriter("/mnt/sdcard/flow_labels.csv");
        writer.write(sb.toString());
        writer.close();

        System.out.println("flow label file construct successfully");
    }
}



